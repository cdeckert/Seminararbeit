\section{Realistic Multiprocessor Scheduling}

Dieser Abschnitt beschäftigt sich mit den in der Realität austretenden Herausforderungen, die bei der Implementierung eines Multi-Thread Programms entstehen. 


In unserer Analyse von Multi-Thread-Programmen wurde bisher davon ausgegangen, dass jedes Programm auf $P$ dedizierten Prozessoren ausgeführt wird. Dies entspricht nicht der Realität. Multi-Thread-Programme werden in der Regel in Umgebungen ausgeführt in denen weitere Programme ablaufen. Es ist zu jedem beliebigen Zeitpunkt möglich, dass weitere Programme ausgeführt werden und Prozessoren belegen. Programme können durch das System unterbrochen werden, auf andere Ressourcen wie Festplatten waren müssen.
Um diese externen Einflüsse zu verwalten werden User-Level Threads, also Threads die durch den User gestartet werden, mit Hilfe von Porgrammzählern und –stapeln verhwaltet. Die eigentliche Verteilung auf Prozesse geschieht durch System-Kernel Scheduler. Das Programm selbst hat keinen Einfluss wann und auf welchem Prozessor ein Thread ausgeführt wird.
Die Brücke zwischen einer Aufgabe und dem Prozessor selbst, wird bei der Verwendung eines Multi-Thread-Programms unter der Verwendung von Aufgaben Pools auf drei Ebenen geschlagen. Wie in Abbildung 2 zu erkennen, werden Aufgaben aus einem Aufgaben-Pool per User-Level Scheduler an Threads verteilt. Diese Threads werden durch das System selbst wiederum mit Hilfe von Kernel-Level Scheduler auf Prozessoren verteilt.
Trotz dessen, dass eine optimale Anzahl  an Threads (ein Thread pro Prozessor) erzeugt wird, kann nicht sichergestellt werden, dass auch die selbe Anzahl an Prozessoren dauerhaft mit der Bearbeitung dieser beschäftigt ist. Daher kann nur mit einer Durchschnittlichen Anzahl an Prozessoren gerechnet werden:

$P_A = 1/T \sum (T-1) (i= 0) p_i$

Um der Realtiät rechnung zu tragen, sollte ein User-Level-Scheduler so designet sein, dass er keine $P$-Fold Speedup sondern einen $P_A$ fold speedup erreicht. Ein schdule wird als greedy bezwichnet falls die Anzahl der Programm Schritte, das Minimum $p_i$ also die anzahl der Prozessor auslastet. In anderen Worten wenn das Programm so viele Schritte ausführt, wie auch zur ausführung bereit stehen.

Theorem 16.3.1


 
