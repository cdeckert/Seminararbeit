\section{Work Distribution}


Wie bereits im vorherigen Kapitel festgestellt, kann ein Thread während der Ausführung unterbrochen werden, eine Aufgabe länger benötigen. Somit kann im Vorhinein nicht sichergestellt werden, dass alle Threads optimal mit Aufgaben ausgelastet sind. Um dieses Problem zu lösen, müssen Aufgaben zur Laufzeit neu verteilt werden. Im Folgenden wird der Ansatz des Work-Stealings zur Umverteilung von Aufgaben zwischen Threads vorgestellt und mit dem naheliegenden Verfahren des Work-Dealing verglichen.

Ein naheliegender Ansatz Aufgaben zwischen Threads zu verteilen ist es jedem Thread die Möglichkeit eigene Aufgaben an weniger oder nicht ausgelastete Threads zu deligieren. Hierzu unterbricht ein Thread die Berechnung seiner Aufgabe und prüft ob andere Threads nicht ausreichend ausgelastet sind. Falls ein solcher Thread gefunden wurde, werden eigene Aufgaben an diesen Thread weitergegeben. Somit kann sichergestellt werden, dass ein Thread, der alle eigene Aufgaben bearbeitet hat auch weiterhin mit Arbeit versorgt wird.
Dieses Push-Verfahren ist jedoch wenig Ressourcen schonend. Ein bereits ausgelasteter Thread muss sich neben seiner eigentlichen Aufgabe auch noch mit der Verteilung von Aufgaben beschäftigen, während ein anderer Thread, der bereits alle Aufgaben bearbeitet hat, auf die Zuteilung neuer Aufgaben wartet. Es ist offensichtlich, dass in diesem Falle die Ressourcen der Threads nicht effizient genutzt werden.

Um die Effizienz zu erhöhen und die Arbeitskraft optimal zu utilitariesieren werden beim Work-Stealing Verfahren Aufgaben durch den Arbeitslosen Thread bei Arbeitenden Threads abgeholt. Die bereits arbeitenden Threads werden durch dieses Verfahren nicht von ihrer eigentlichen Arbeit abgehalten und ein arbeitsloser Thread kann sich Aufgaben selbst zuteilen auf die er im Work-Dealing Verfahren warten müsste.

Konkret wird ein solcher Work-Stealing Algorithmus durch eine Double-Endling-Queue (DEQueue) realisiert. JedemThread ist eine solche DEQueue zugeordnet. Auf diese aknn der Thread mit den Methoden push-top, um Aufgaben der Queue auf einer Seite und push-bottom um Aufgaben auf der anderen Seite der Queue hinzuzufügen zugreifen. Ebenfalls gibt es die Möglichkeit Aufgaben sowohl von der einen Seite per pop-top als auch von der anderen Seite per pop-bottom aus der Queue abzurufen. Wird eine Aufgabe einer DEQueue hinzugefügt so geschieht dies per push-bottom. Aufgaben die durch den eigenen Thread abgerufen werden, werden per popBottom abgerufen. Aufgaben, die durch andere Threads abgerufen werden, werden per popTop abgerufen.

//HIER ALGORITHMUS EINFÜGEN

Wie in Codebeispeil 1 in Zeile 12-16 zu sehen, wählt ein arbeitsloser Thread zufällig einen anderen Thread aus, um dort, falls möglich, eine Aufgabe zu stehlen und selbst zu bearbeiten. Der Beispiel-Code bietet keinen Abbruchbeding an. Eine solche kann beispielsweise genutzt werden aus XY Buch (Kapitel 17.6).

Wie bereits zuvor bemerkt, kann es durch die Kombination von kurzlebigen Aufgaben, die auf verschiedene Threads verteilt werden, die wiederum durch das System auf Prozessoren verteilt werden dazu kommen, dass ein Thread trotz vorhandener Arbeit durch Das System angehalten wird. Um diesem Problem zu entgehen wird der Befehl yield() in jedem Thread implementiert und direkt vor dem Stehlen einer Aufgabe ausgeführt. So wird sichergestellt, dass der Thread vom Betriebssystem behandelt wird und so weiterarbeiten kann.



