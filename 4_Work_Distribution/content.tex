\section{Work Distribution}


Wie im vohergehenden Kapitel angesprochen, kann die Anzahl der pro Thread bearbeiteten Threads varriieren. Um eine möglichst guten Speedup zu erreichen, ist ein Arbeits-Verteilungs-Algorithmus notwendig, der die einzelnen Threads optimal auslastet. Im folgenden wird das Konzept des Stehlens von Arbeit vorgestellt.





Wir haben verstanden, dass der Schlüssel um eine gute Speedup zu bewaren, die möglichkeit ist auf User level Threads mit Tasks zu versorgen, daraus folgt dann eine greedy as possible distribution. Daher ist ein Work distribution algorithmus.

Eine möglichkeit ist der Work dealing: Der überladene Thread versucht seine Taks an andere Threads abzugeben. Dieser Algorithmus wirkt im ersten Moment vorteilhaft. Näherbetrachtet stellt man fest, dass der bereits überladene Thread weiteren Aufwand dafür aufwenden muss seine Tasks an andere Threads abzugeben. Stattdessen verwenden wir Work trealing. In diesem Falle versucht ein Thread der out-of-work läuft Taks von anderen Threads zu stehelen. Die bereits laufenden threads verschwenden dadurch keinen Aufwand, um Ihre Tasks abzugeben.

\subsection{Work stealing}

Work stealing funktioniert so, dass jeder Thread einen Pool an Tasks aufbaut, die auszuführen sind (eine doube-ended queue). Sie beihaltet die funktionionen push bottom / push top, pop bottom und pop top. Der Thread selbst nutzt dabei popButtom um eine Task zu removen von seiner eigenen Queue. Der Diebt wählt einen beliebigen Thread als Opfer zufällig aus und stielt eine Taks mit hilve von popTop() für sich selbst. 

Damit ein Thread nicht endlos nach neuen Tasks suchen muss, kann eine barriere für das suchen implementiert werden (Kapitel 17).

\subsection{Yielding and Multiprogramming}

Um Fortschritt zu garantieren, auch während ein Thread versucht Taks zu stehlen, ruft der stehlende Thread zuvor yield auf. Dies erlaubt dem Prozess wieder zu reschedulen, damit die Arbeit getan wird


